---
title: "Estimating transmissibility with population stratification"
author: Thibaut Jombart, Hugo Gruson
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    code_folding: "hide"
link-citations: no
params:
  epicurve_unit: "week"
  incomplete_days: 7
  r_estim_window: 21
  si_mean: 4.2
  si_sd: 4.9
  si_dist: "gamma"
  use_epiparameter: true
  epiparameter_pathogen: "SARS_CoV_2_wildtype"
  local: true
  data_file: "covid_admissions_uk_2020_10_24.xlsx"
# bibliography: "../biblio/biblio.bib"
---

```{r settings, echo = FALSE}
knitr::opts_chunk$set(
  fig.width = 9,
  fig.height = 5,
  dpi = 90,
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  out.width = "100%"
)
```

# Outline of the report

## Estimating transmissibility from stratified population

This report provides a template for estimating transmissibility (i.e., how fast
a disease spreads) from a stratified population. It performs basic descriptive
analyses, and uses different approaches for estimating transmissibility. The key
steps of the report include:

* importing the data from an external file
* identifying key variables in the data
* producing global and stratified epidemic curves
* estimating the growth rate and doubling time from epidemic curves
* estimating the instantaneous reproduction number from epidemic curvse

# Data preparation

## Loading libraries

The following code loads required packages; if you are using _Rstudio_ and are
missing some of the packages, you will be prompted for installing them
automatically. If you are using this report in a
[_reportfactory_](https://www.reconverse.org/reportfactory/), you can run
`reportfactory::install_deps()` to install all missing dependencies.


```{r}
library("tidyverse")
library("here")
library("rio")
library("linelist")
library("scales")
library("janitor")
library("rmdformats")
library("kableExtra")
library("incidence2")
library("i2extras")
library("distcrete")
library("epitrix")
library("epiparameter")
library("EpiNow2")
```

```{r}
custom_grey <- "#505B5B"
green_grey <- "#5E7E80"
pale_green <- "#b2d1cc"
dark_green <- "#005C5D"
dark_pink <- "#B45D75"

theme_custom <- theme(
  plot.background = element_rect(fill = "white"),
  panel.grid.major = element_line(colour = "#96a3a3"),
  panel.grid.minor = element_line(colour = "#9DC1C2", linetype = "dotted"),
  panel.background = element_rect(colour = custom_grey, fill = "white"),
  strip.background = element_rect(fill = green_grey, color = "white", size = 1),
  strip.text = element_text(colour = "white"),
  text = element_text(size = 16, colour = custom_grey),
  axis.ticks = element_line(colour = custom_grey)
  #aspect.ratio = 9 / 16
)
theme_set(theme_custom)
```

##  Importing the data

The data file is named "*covid_admissions_uk_2020_10_24.xlsx*" and is located in
the *data/* folder. To adapt this report to another dataset, change the name of
the file in the script below. Note that incomplete file names can be used: the
first matching file in `data/` will be used.

```{r}
if (params$local) {
  
  data_path <- here::here("data", params$data_file) 
  
} else {
  
  data_path <- file.path("https://github.com/epiverse-trace/data_pipelines/raw/main/data", params$data_file) 
  
}
```

```{r}
dat_raw <- data_path %>%
  rio::import() %>%
  tibble() %>%
  mutate(date = as.Date(date)) # date-time -> date
```

Once imported into __R__, the dataset called `dat` includes:

* `date`: the date of admission
* `region`: the NHS region
* `org_name`: the full name of the NHS trust
* `org_code`: a short code for the NHS trust
* `n`: number of new, confirmed COVID-19 cases admitted, including inpatients
  who tested positive on that day, and new admissions with a positive test

## Identifying key data

__Note__: this is not used for now, as there is no integration of linelist with
other existing tools.

Here we identify the key data needed in the analyses, including:

* the dates to be used, here, dates of hospital admission
* the strata of the population, here, coarse geographic locations (NHS regions)
* the case counts; this would not be needed if the data was a raw linelist, and
  not already aggregated counts

```{r}
date_var <- "date"
group_var <- "region"
count_var <- "n"

dat <- dat_raw %>%
  make_linelist(date_admission = date_var,
                location = group_var,
                counts = count_var,
                allow_extra = TRUE)
```

# Descriptive analyses

## Epidemic curves

This section creates epidemic curves ("_epicurves_"), with or without stratification.

```{r}
# convert daily incidence into weekly incidence using incidence2
dat_i <- dat_raw %>%
  incidence("date",
            interval = params$epicurve_unit,
            counts = {{count_var}},
            groups = {{group_var}})

# general variables for automatic customisation of plots
n_groups <- length(unique(unlist(dat_i[group_var])))
small_counts <- max(dat_i[count_var]) < 20

# plot with regions as colors if less than 9 categories
if (n_groups <= 9L) {
dat_i %>%
  plot(fill = group_var, col_pal = muted, color = "white",
       alpha = 1, angle = 45, legend = "bottom",
       show_cases = small_counts) +
  guides(fill = guide_legend(title=NULL)) +
  labs(title = "Incidence of cases over time")
} else {
dat_i %>%
  regroup() %>% 
  plot(angle = 45, color = "white",
       fill = green_grey,
       alpha = 1,
       show_cases = small_counts) +
  labs(title = "Incidence of cases over time")
}
```

```{r fig.height = 5 / 3 * n_groups}
dat_i %>%
  facet_plot(angle = 45,
             date_format = "%d %b %y",
             color = "white",
             fill = green_grey,
             alpha = 1,
             n_breaks = 6,
             nrow = n_groups,
             show_cases = small_counts)
```

## Numbers of cases

This graph shows the total number of cases per group:

```{r }
total_cases <- dat %>%
  select_tags(location, counts) %>%
  group_by(location) %>%
  summarise(cases = sum(counts)) %>%
  arrange(location)

ggplot(total_cases, aes(x = cases, y = location)) +
  geom_col(fill = green_grey) +
  labs(x = "Total number of cases", y = NULL)

total_cases %>%
  mutate(percentage = cases / sum(cases),
         percentage = paste(round(percentage * 100, 2), "%")) %>% 
  adorn_totals() %>%
  mutate(cases = format(cases, scientific = FALSE, big.mark = " ")) %>% 
  set_names(toupper) %>%   
  kbl() %>%
  kable_paper("striped", font_size = 18, full_width = FALSE) %>%
  row_spec((1:nrow(total_cases))[c(FALSE, TRUE)],
           background = pale_green)
```


# Serial interval distribution

## Explanations

The _serial interval_ ($si$) is the delay between the date of symptom onsets of primary
case and the secondary cases they have infected. Because this delay varies from
one transmission pair to another, we will characterise this variation using a
probability distribution. This distribution is a key input to methods use for
estimating the reproduction number ($R$). 

Here, we assume that the mean and standard deviation of the $si$ is known, and
provided as an input by the user. We model the $si$ distribution as a
discretized Gamma. 

## Results

```{r, eval = params$use_epiparameter}
si_epiparameter <- epiparameter::epidist(params$epiparameter_pathogen, "serial_interval")
si_params <- si_epiparameter$param
si_dist <- si_epiparameter$dist
si_mean <- si_params[[1]]
si_sd   <- si_params[[2]]
```

```{r, eval = !params$use_epiparameter}
si_mean <- params$si_mean
si_sd <- params$si_sd
si_dist <- params$si_dist
si_cv <- si_sd / si_mean
si_params <- epitrix::gamma_mucv2shapescale(mu = si_mean, cv = si_cv)
```

```{r}
si <- distcrete(si_dist,
                interval = 1,
                w = 0,
                si_params[[1]],
                si_params[[2]])
si_x <- seq(1L, to = si$q(.999), by = 1L)
```

```{r}
ggplot(data.frame(delay = si_x, prob = si$d(si_x)),
       aes(x = delay, y = prob)) +
  geom_col(fill = green_grey) +
  labs(title = "Serial interval distribution",
       x = "Days from primary to secondary onset",
       y = "Probability",
       subtitle = sprintf(
         "%s distribution | mean: %.1f days ; sd: %.1f days",
         si_dist, si_mean, si_sd))
```

# Growth rate ($r$) and reproduction number ($R$) {.tabset}

## _i2extras_

### Explanations

The package *i2extras* is used to estimate daily growth rates '_r_', using Poisson
GLMs fitted to epidemic curves. These estimates can be biased by reporting
delays. Here, we exclude the last `r params$incomplete_days` days as incomplete,
and retain a total of `r params$r_estim_window` days to estimate the growth
rate.

Growth rates can be interpreted as the percent change in daily
incidence. Positive numbers indicate growth, while negative numbers indicate
decline, of the epidemic. For instance:

* $r = 0.02$ means that the number of new cases increases on average by 2% each day
* $r = -0.13$ means that the number of new cases decreases on average by 13% each day

Growth rates can also be converted to _doubling times_ (when $r > 0$) or
_halving times_ (when $r < 0$), defined as the time it takes for the daily
incidence to double (respectively, halve).

For more information on growth rates, see this [blog post by Pr Julia Gog](https://plus.maths.org/content/epidemic-growth-rate).

### Results

This section contains:

* graphs showing the models fitted to epidemic curves, with their associated 95% confidence
intervals (CI)

* graphs showing the estimates of the growth rates ($r$) with their 95% CI

* a table summarizing estimtes of $r$ and the associated period (doubling or
  halving time); all results show point estimates and their 95% CI

```{r fig.height = 5 / 3 * n_groups}
last_date <- dat %>%
  pull(date) %>%
  max()

# version using keep_first and keep_last from i2extras
days_to_keep <- params$incomplete_days + params$r_estim_window
i_recent <- dat_raw %>%
  incidence("date",
            counts = {{count_var}},
            groups = {{group_var}}) %>% 
  keep_last(days_to_keep) %>%  # keep data for fitting 
  keep_first(params$r_estim_window) # remove incomplete data

last_trends <- i_recent %>%
  fit_curve(model = "poisson")
# version with negbin model needs more iterations to converge
# fit_curve(model = "negbin", control = glm.control(maxit = 1e3))
plot(last_trends,
     angle = 45,
     date_format = "%d %b %y",
     color = "white",
     fill = green_grey,
     alpha = .8,
     n_breaks = 12,
     nrow = n_groups,
     show_cases = small_counts)
```

```{r}
last_trends %>%
  growth_rate %>%
  ggplot(aes(y = .data[[group_var]]), fill = custom_grey) +
  geom_point(aes(x = r), color = dark_green) +
  geom_errorbar(aes(xmin = r_lower, xmax = r_upper), color = dark_green) +
  scale_x_continuous(labels = scales::percent) +
  geom_vline(xintercept = 0, color = dark_pink) +
  labs(title = "Estimates of daily growth rates",
       subtitle = sprintf(
         "based on data from %s - %s",
         format(min(get_dates(i_recent)), "%d %B %Y"),
         format(max(get_dates(i_recent)), "%d %B %Y")),
       y = "",
       x = "Daily rate of change")

last_trends %>%
  growth_rate() %>%
  dplyr::select(-c(1,3)) %>%
  rename(period = growth_or_decay) %>% 
  mutate("period type" = paste(period, "time"),
         r = paste(round(r * 100, 1), "%"),
         r_ci = sprintf(
           "[%1.1f %% ; %1.1f %% ]",
           r_lower * 100,
           r_upper * 100),
         time = round(time, 1),
         time_ci = sprintf(
           "[%.1f ; %.1f]",
           time_lower,
           time_upper)
         ) %>%
  dplyr::select("Daily growth rate" = r,
         "Growth rate (95% CI)" = r_ci,
         "period type",
         "Duration (days)" = time,
         "Duration (95% CI)" = time_ci) %>%
  set_names(toupper) %>%   
  kbl() %>%
  kable_paper("striped", font_size = 18, full_width = FALSE) %>%
  row_spec((1:nrow(total_cases))[c(FALSE, TRUE)],
           background = pale_green)
```

#### Estimating $R$ from the growth rates

Wallinga and Lipsitch have introduced methods for converting daily growth rates
($r$) into reproduction numbers ($R$) [@Wallinga2007-hw], when information on
the serial interval distribution is available. $R$ represents the average number
of secondary cases generated by an infected patient. Like the daily growth rate,
$R$ can be used to gauge the dynamics of an epidemic:

* $R > 1$: the epidemic will grow exponentially
* $R < 1$: the epidemic will decline exponentially

Note that $R$ only speaks to the number of new cases created, not how fast these
are generated, so on its own it is not sufficient to indicate how fast the
epidemic is growing. For a comparison of $r$ and $R$, we recommend reading this
[blog post by Pr Julia Gog](https://plus.maths.org/content/epidemic-growth-rate).

Here, we use the procedure implemented in `epitrix` to derive samples of $R$
values compatible with the values of $r$ estimated in the previous section, and
with the provided serial interval.

This section contains:

* a graph showing the distribution of $R$ values estimated from the daily growth
  rates; each violin shows the density of values based on a sample of 500 from
  the Student distribution associated with the estimate of $r$; the line range
  represents the 95% confidence interval (horizontal segment) and the median
  (dot)
  
* a table summarizing the estimated distributions of $R$ values 

```{r }
res_R_wl <- last_trends %>%
  mutate(R = map(model, epitrix::lm2R0_sample, w = si, 500)) %>%
  dplyr::select({{group_var}}, R) %>%
  unnest(R)

res_R_wl_smry <- res_R_wl %>%
  group_by(.data[[group_var]]) %>%
  summarise(mean = mean(R),
            median = median(R),
            q_0.025 = quantile(R, 0.025),
            q_0.975 = quantile(R, 0.975))

res_R_wl %>%
  ggplot(aes(y = .data[[group_var]]), fill = custom_grey) +
  geom_violin(aes(x = R), fill = pale_green, color = green_grey) +
  geom_pointrange(data = res_R_wl_smry,
                  aes(x = median, xmin = q_0.025, xmax = q_0.975),
                  color = dark_green) +
  geom_vline(xintercept = 1, color = dark_pink) +
  labs(title = "Reproduction numbers estimated from growth rates",
       subtitle = sprintf(
         "based on data from %s - %s",
         format(min(get_dates(i_recent)), "%d %B %Y"),
         format(max(get_dates(i_recent)), "%d %B %Y")),
       y = "",
       x = "Reproduction number")

res_R_wl_smry %>%
  mutate(
    mean = round(mean, 2),
    median = round(median, 2),
    `95% ci` = sprintf(
           "[%1.2f ; %1.2f]",
           q_0.025,
           q_0.975)) %>%
  dplyr::select(-c(q_0.025, q_0.975)) %>%
  rename(
    "mean $R$" = mean,
    "median $R$" = median) %>% 
  set_names(toupper) %>%   
  kbl() %>%
  kable_paper("striped", font_size = 18, full_width = FALSE) %>%
  row_spec((1:nrow(res_R_wl_smry))[c(FALSE, TRUE)],
           background = pale_green)
```

## _EpiEstim_ 

### Explanations


### Results

#### Global transmissibility

These analyses present results for the global incidence, i.e. without
stratification. Results include:
 
* a graph of the estimates of $R_t$ over time, with associated 95% credibility
  intervals
  
* a table summarising these results for the last two weeks


```{r }
library(EpiEstim)

# Function to process a distrcrete object and output `si_discr` argument for
# EpiEstim::make_config

wrap_si <- function(x) {
  stopifnot(inherits(x, "distcrete"))
  max_x <- x$q(.999)
  x <- si$d(seq_len(max_x))
  x[1] <- 0
  x <- x / sum(x)
  x  
}


# Function to process output from `EpiEstim::estimate_R` and output a tibble
# with dates, mean R, and associated confidence intervals
#'
#' @param x An `estimate_R` object
#' @param incid (Optional) The incidence2 object on which R values have been
#'   estimated.
wrap_res <- function(x, incid = NULL) {
  stopifnot(inherits(x, "estimate_R"))
  out <- tibble::tibble(x$R)
  out <- dplyr::select(out,
                       start = t_start,
                       end = t_end,
                       mean = `Mean(R)`,
                       sd = `Std(R)`,
                       median = `Median(R)`,
                       lower = `Quantile.0.025(R)`,
                       upper = `Quantile.0.975(R)`)
  if (!is.null(incid)) {
    stopifnot(inherits(incid, "incidence2"))
    dates <- unique(incidence2::get_dates(incid))
    out$start <- dates[out$start]
    out$end <- dates[out$end]
  }
  
  class(out) <- c("R_estimate", class(out))
  out
}

# Daily incidence
dat_i_day <- dat_raw %>%
  incidence("date",
            interval = 1L,
            counts = {{count_var}},
            groups = {{group_var}})

# Run EpiEstim
ee_config <- make_config(si_distr = wrap_si(si))

res_epiestim_global <- dat_i_day %>% 
  regroup() %>%
  pull(n) %>%
  estimate_R(config = ee_config) %>%
  wrap_res(dat_i_day)

# Graph of all values over time
ggplot(res_epiestim_global, aes(x = end)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = pale_green) +
  geom_line(aes(y = median), color = dark_green) +
  geom_hline(yintercept = 1, color = dark_pink) +
  scale_x_date(breaks = scales::pretty_breaks(n = 8), date_label = "%d %b %Y") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  labs(x = "",
       y = "Instantaneous reproduction number\\(Rt)",
       title = "Estimates of Rt (EpiEstim)")

# Table
res_epiestim_global %>%
  tail(14) %>% 
  mutate(
    date = end,
    mean = round(mean, 2),
    median = round(median, 2),
    `95% ci` = sprintf(
           "[%1.2f ; %1.2f]",
           lower,
           upper)) %>%
  dplyr::select(-c(start, end, sd, lower, upper)) %>%
  dplyr::select(date, everything()) %>%
  rename(
    "mean $R$" = mean,
    "median $R$" = median) %>% 
  set_names(toupper) %>%   
  kbl() %>%
  kable_paper("striped", font_size = 18, full_width = FALSE) %>%
  row_spec((1:14)[c(FALSE, TRUE)],
           background = pale_green)
```



#### Transmissibility by group

```{r fig.height = 5 / 3 * n_groups}
# Get results by group, keeping only the last 14 days of data
res_epiestim_group <- dat_i_day %>% 
  nest(data = c(date_index, n)) %>%
  mutate(res_epiestim = map(data, ~ wrap_res(estimate_R(.$n, config = ee_config), dat_i_day))) %>%
  unnest(res_epiestim) %>%
  dplyr::select(-data)

# Graph of all values over time
ggplot(res_epiestim_group, aes(x = end)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = pale_green) +
  geom_line(aes(y = median), color = dark_green) +
  geom_hline(yintercept = 1, color = dark_pink) +
  scale_x_date(breaks = scales::pretty_breaks(n = 8), date_label = "%d %b %Y") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  facet_wrap( ~ .data[[group_var]], ncol = 1) +
  labs(x = "",
       y = "Instantaneous reproduction number\\(Rt)",
       title = "Estimates of Rt (EpiEstim)")
```

```{r }
# Plot of latest estimates
res_epiestim_group %>%
  filter(end == max(end)) %>%
  ggplot(aes(y = .data[[group_var]]), fill = custom_grey) +
  geom_point(aes(x = median), color = dark_green) +
  geom_errorbar(aes(xmin = lower, xmax = upper), color = dark_green) +
  geom_vline(xintercept = 1, color = dark_pink) +
  labs(title = "Estimates of Rt (EpiEstim)",
       subtitle = sprintf(
         "based on data from %s - %s",
         format(max(get_dates(dat_i_day) - 7), "%d %B %Y"),
         format(max(get_dates(dat_i_day)), "%d %B %Y")),
       y = "",
       x = "Instantaneous Reproduction Number (Rt)")

res_epiestim_group %>%
  filter(end == max(end)) %>% 
  mutate(
    mean = round(mean, 2),
    median = round(median, 2),
    `95% ci` = sprintf(
           "[%1.2f ; %1.2f]",
           lower,
           upper)) %>%
  dplyr::select(-c(sd, lower, upper)) %>%
  rename(
    "mean $R$" = mean,
    "median $R$" = median) %>% 
  set_names(toupper) %>%   
  kbl() %>%
  kable_paper("striped", font_size = 18, full_width = FALSE) %>%
  row_spec((1:n_groups)[c(FALSE, TRUE)],
           background = pale_green)
```


## _R0_

### Explanations

### Results

```{r}
library(R0)

mGT <- generation.time("empirical", si_x)

# Helper function to get R0 outputs in a tidy format, compatible with pipelines
r0_quantiles <- function(Rt) {
  
  data.frame(
    q50   = Rt$R,
    q2.5  = Rt$conf.int$lower,
    q97.5 = Rt$conf.int$upper
  )
  
}

last_trends_r0 <- dat %>% 
  filter(between(.data[[date_var]], last_date - (params$incomplete_days + params$r_estim_window), last_date - params$incomplete_days)) %>% 
  arrange(.data[[date_var]]) %>% 
  group_by(.data[[group_var]], .data[[date_var]]) %>% 
  summarise({{count_var}} := sum(.data[[count_var]])) %>% 
  group_by(.data[[group_var]]) %>% 
  summarise(
    r0_quantiles(estimate.R(.data[[count_var]], mGT, .data[[date_var]], begin = 1L, end = params$r_estim_window, nsim = 1e4, method = "TD")$estimates$TD),
    {{date_var}} := head(.data[[date_var]], params$r_estim_window)
  )

last_trends_r0 %>% 
  ggplot(aes(x = date, y = q50, ymin = `q2.5`, ymax = `q97.5`)) +
    geom_ribbon(fill = "grey70") +
    geom_line() +
    facet_wrap(vars(region)) +
    geom_hline(yintercept = 1, color = "red", linetype = "dotted") +
    labs(title = "Estimates of effective reproduction numbers (Reff)",
       subtitle = sprintf(
         "based on data from %s - %s",
         format(last_date - (params$incomplete_days + params$r_estim_window), "%d %B %Y"),
         format(last_date - params$incomplete_days, "%d %B %Y")),
       y = "Reff")
```


## _EpiNow2_ 

### Explanations

### Results

```{r}
# TODO: remove harcoded SARS-CoV-2 params
generation_time <- get_generation_time(
  disease = "SARS-CoV-2",
  source = "ganyani"
)
incubation_period <- get_incubation_period(
  disease = "SARS-CoV-2",
  source = "lauer"
)
reporting_delay <- list(
  mean = convert_to_logmean(3, 1),
  mean_sd = 0.1,
  sd = convert_to_logsd(3, 1),
  sd_sd = 0.1,
  max = 10
)
```

#### Global transmissibility

```{r}
rt_epinow2 <- i_recent %>%
  regroup() %>% 
  dplyr::rename(
    confirm = .data[[count_var]],
    date    = date_index
  ) %>% 
  epinow(
    generation_time = generation_time,
    delays = delay_opts(incubation_period, reporting_delay),
    stan = stan_opts(samples = 10, chains = 1),
    horizon = 0,
    CrIs = c(0.5, 0.95),
    return_output = TRUE,
    verbose = FALSE,
    logs = NULL
  )
```

```{r}
plot(rt_epinow2, "R")
```

```{r}
rt_epinow2$estimates$summarised %>% 
  dplyr::filter(variable == "R") %>% 
  tail(14) %>% 
  dplyr::select(date, mean, median, lower_95, upper_95) %>% 
  mutate(
    "mean $R$" = round(mean, 2),
    "median $R$" = round(median, 2),
    "95% ci" = sprintf(
       "[%1.2f ; %1.2f]",
       lower_95,
       upper_95
    ),
    .keep = "unused"
  ) %>% 
  kbl() %>% 
  kable_paper("striped", font_size = 18, full_width = FALSE) %>%
  row_spec((1:14)[c(FALSE, TRUE)],
           background = pale_green)
```

#### Transmissibility by group

```{r epinow2 with epiparameter, message = FALSE}
rt_by_group <- i_recent %>%
  dplyr::rename(
    confirm = .data[[count_var]],
    date    = date_index,
    region  = .data[[group_var]]
  ) %>% 
  regional_epinow(
    generation_time = generation_time,
    delays = delay_opts(incubation_period, reporting_delay),
    stan = stan_opts(samples = 10, chains = 1),
    horizon = 0,
    CrIs = c(0.5, 0.95),
    return_output = TRUE,
    verbose = FALSE,
    logs = NULL
  )
```

```{r}
rt_by_group$summary$plots$R
```

```{r}
rt_by_group$summary$summarised_results$data %>% 
  dplyr::filter(metric == "Effective reproduction no.") %>% 
  dplyr::select(region, mean, median, lower_95, upper_95) %>% 
  dplyr::mutate(
    "95% ci" = sprintf(
       "[%1.2f ; %1.2f]",
       lower_95,
       upper_95
    ),
    .keep = "unused"
  ) %>% 
  kbl() %>% 
  kable_paper("striped", font_size = 18, full_width = FALSE) %>%
  row_spec((1:n_groups)[c(FALSE, TRUE)],
           background = pale_green)
```
